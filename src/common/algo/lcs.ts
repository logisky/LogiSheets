/**
 * Return words according to the length of the longest common subsequence.
 *
 * Only those words whose lcs with pattern is pattern itself will be returned
 * and also words are sorted by their length.
 * if pattern = 'at' and beMatched = ['bath', 'banana', 'ant', 'at']
 * then ['at', 'ant', 'bath'] will be returned.
 */
export function lcsLenMatch<T>(
    pattern: string,
    beMatcheds: readonly T[],
    getValue: (beMatched: T) => string,
    caseSensitive = true,
) {
    const result: { beMatched: T, matchedMap: Map<number, number> }[] = []
    if (pattern === '')
        return result
    // tslint:disable-next-line: no-loop
    for (const beMatched of beMatcheds) {
        const word = getValue(beMatched)
        const candidateWord = caseSensitive ? word : word.toLowerCase()
        const target = caseSensitive ? pattern : pattern.toLowerCase()
        const matrix:
            readonly (readonly number[])[] = getLcsMatrix(target, candidateWord)
        const lcsLen: number = matrix[target.length][candidateWord.length]
        if (lcsLen !== target.length)
            continue
        const wordIndex:
            readonly number[] = backTrackLcs(matrix, target, candidateWord)
        const matchedMap = new Map<number, number>()
        wordIndex.forEach((value: number, index: number): void => {
            matchedMap.set(index, value)
        })
        result.push({ beMatched, matchedMap })
    }

    return result
}

/**
 * Gets the length of the  longest common subsequence between s1 and s2.
 */
export function getLcsLen(s1: string, s2: string): number {
    return getLcsMatrix(s1, s2)[s1.length][s2.length]
}

/**
 * Get the matrix of longest common subsequence(lcs) between s1 and s2.
 *
 * For more: https://en.wikipedia.org/wiki/Longest_common_subsequence_problem
 */
function getLcsMatrix(s1: string, s2: string): readonly (readonly number[])[] {
    const l1: number = s1.length
    const l2: number = s2.length
    const lcsLen: number[][] = []
    // Initialize the 2-D array.
    // tslint:disable-next-line: no-loop-statement
    for (let i = 0; i <= l1; i += 1) {
        lcsLen.push([])
        // tslint:disable-next-line: no-loop-statement
        for (let j = 0; j <= l2; j += 1)
            lcsLen[i].push(0)
    }
    // tslint:disable-next-line: no-loop-statement
    for (let i = 1; i <= l1; i += 1)
        // tslint:disable-next-line: no-loop-statement
        for (let j = 1; j <= l2; j += 1)
            if (s1[i - 1] === s2[j - 1])
                lcsLen[i][j] = lcsLen[i - 1][j - 1] + 1
            else
                lcsLen[i][j] = Math.max(lcsLen[i][j - 1], lcsLen[i - 1][j])

    return lcsLen
}

/**
 * This function used to back track the matrix generated by getLcsMatrix.
 *
 * During the back track, we could find the matched characters.
 * Returns the indices of these characters.
 */
function backTrackLcs(
    matrix: readonly (readonly number[])[],
    s1: string,
    s2: string,
): readonly number[] {
    const s2Index: number[] = []
    let i = s1.length
    let j = s2.length
    let target = matrix[i][j]
    if (matrix[i][j] === 0)
        return s2Index
    // tslint:disable-next-line: no-loop-statement
    while (i >= 1 && j >= 1) {
        // tslint:disable-next-line: no-loop-statement
        while (matrix[i][j - 1] === target)
            j -= 1
        if (s1[i - 1] === s2[j - 1]) {
            s2Index.unshift(j - 1)
            i -= 1
            j -= 1
            target -= 1
        } else if (matrix[i - 1][j] >= matrix[i][j - 1])
            i -= 1
        else
            j -= 1
    }
    return s2Index
}
